% \iffalse meta-comment
%
% Copyright (C) 2015 by Pascal Germroth <pascal@germroth.name>
% ------------------------------------------------------------
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.2
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
%    http://www.latex-project.org/lppl.txt
%
% and version 1.2 or later is part of all distributions of LaTeX 
% version 1999/12/01 or later.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{autoverbalign.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{autoverbalign}
%<*package>
    [2015/03/16 v1.0 automatic tabbing-like environment]
%</package>
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{autotabbing}
\usepackage{autoverbalign}
\usepackage{xcolor}
\usepackage{showexpl}
\usepackage{listings}
%\usepackage{microtype}
%\usepackage{lua-visual-debug}
\EnableCrossrefs
\CodelineIndex
\RecordChanges

%\usepackage[margin=1cm]{geometry}


\lstdefinelanguage{Haskell}{
  morekeywords={case,of,do,return},
  morecomment=[l]{--},
  morecomment=[s]{\{-}{-\}},
  literate=
    {->}{$\rightarrow\;$}2
    {<-}{$\leftarrow\;$}2
    {:}{$\;:\;$}1
    {::}{$::\;$}2
    {[]}{$[\,]$}2
}
\lstset{
  language=Haskell,
  columns=fullflexible,
}

\parindent=0pt

\usepackage{newverbs}

\newverbcommand{\mychunks}{%
  \setbox\verbbox\hbox\bgroup\strut%
}{%
  \egroup%
  {%
    \setlength{\fboxsep}{-1pt}%
    \hskip1pt%
    \fcolorbox{red}{white}{\box\verbbox}%
    \hskip1pt%
  }%
}

\newcommand{\DescribeKey}[1]{\DescribeEnv{#1}}

\makeatletter
\newenvironment{dconsume}{\autoverbalign@consume}{\endautoverbalign@consume}

\newcommand{\drunW}[2]{%
  \vbox{%
    \autoverbalignsetup{#1}%
    \hbox{\fbox{\vbox{\autoverbalign@process}}}%
    #2%
  }%
}
\newcommand{\drunX}[1]{\drunW{#1}{}}

\newcommand{\drunZ}[1]{%
  \drunW{#1}{\par\vspace{5pt}\hbox{\strut}}}

\newcommand{\drun}[1]{%
  \drunW{#1}{%
    \par\vspace{5pt}%
    \hbox{\strut\scriptsize\texttt{\detokenize{#1}}}}}
\makeatother

\begin{document}
\changes{v1.0}{2015/03/16}{Initial version}

\GetFileInfo{autoverbalign.dtx}

\DoNotIndex{\newcommand,\newenvironment}

\title{The \textsf{autoverbalign} package\thanks{This document
  corresponds to \textsf{autoverbalign}~\fileversion, dated \filedate.}}
\author{Pascal Germroth \\ \texttt{pascal@germroth.name}}

\maketitle

\section{Introduction}

This package provides a \textsf{verbatim}-like environment which attempts to
recognize manual alignment of the monospace input...

\begin{dconsume}
f :: (a -> IO b) -> [Maybe a] -> IO [b]                      -- type
f    g              (x:xs)    = case x of Just y -> do       -- have val
                                            z <- g x         -- process
                 {-mmmmmmmmmm-}             zs <- f g xs     -- recurse
                 {-llllllllll-}             return (z:zs)    -- done
                                          Nothing -> f g xs  -- skip
f    _              []        = []                           -- end
\end{dconsume}
\medskip
\hfill
{\small\drunX{indent=,chunk=\verb}}
\hfill
\medskip

...and keeps this even when typesetting using a proportional font,
here with additional processing through the \textsf{listings} package:

\medskip
\hfill
{\small\drunX{chunk=\lstinline}}
\hfill
\medskip

Originally written for pretty-printing Haskell-like code without an external
preprocessor, it can be useful for any occasion where no cell-wise formatting
is required but inserting |&|s would be annoying.

\section{Usage}

The package is loaded as |\usepackage|\oarg{kvargs}|{autoverbalign}|.
It inherits document class options like |draft|.

\DescribeMacro{\autoverbalignsetup}
In the document options can also be set using |\autoverbalignsetup|\marg{kvargs}.

\DescribeEnv{autoverbalign}
This is the main verbatim environment.
If you don't want to set options but the content starts with |[|,
use empty~|[]| to prevent it from trying to parse the entire content
as \meta{kvargs}.

\medskip
\qquad\vbox{
  |\begin{autoverbalign}|\oarg{kvargs}\\
  \meta{content}\\
  |\end{autoverbalign}|
}\medskip

\DescribeMacro{\newautoverbalign}
You can define custom versions using
|\newautoverbalign|\oarg{kvargs}\marg{name}.

\medskip\qquad\vbox{
  |\begin|\marg{name}\oarg{kvargs}\\
  \meta{content}\\
  |\end|\marg{name}
}\medskip


\DescribeKey{chunk}
The environment acts like (and is based on) the |verbatim| environment from
the \textsf{verbatim} package. It splits the text contained into \emph{chunks}
delimited by \emph{tabs} which are inferred from the whitespace in the code.
It puts the chunks in a \textsf{autotabbing} environment for alignment, wrapped
inside a |\verb|-like command, i.e. |\cmd|\meta{char}\meta{content}\meta{char}.
The character is chosen automatically as one not contained in the content, and
never |{|. By default we use |\verb|, but it is recommended to set a custom
command using |chunk=|\meta{code} for proportional typesetting.

\bigskip
\begin{dconsume}
do something
   return 1
\end{dconsume}
\hfill
\drunZ{indent=,chunk=\verb*}%
\hfill
\drun{chunk=\lstinline}%
\hfill
\drun{chunk=\collectverb{\rmfamily}}%
\hfill
\bigskip

\subsection{Alignment}

\autoverbalignsetup{draft,chunk=\verb*}
The environment interprets \emph{two} or more spaces before a nonspace as an
explicit tabstop, and attempts to group and align chunks of neighboring text
space at the same column (here marked red), which we call \emph{explicit tabs}

\bigskip
\begin{dconsume}
m m m  m m m
n n n  n n n
l l l  l l l
\end{dconsume}
\hfill
\drun{chunk=\verb*}%
\hfill
\drun{chunk=\lstinline}%
\hfill
\bigskip

\DescribeKey{implicitbefore}
\DescribeKey{implicitafter}
There is a heuristic for \emph{implicit tabs} (here marked blue) too.
Starting from an explicit tab we search for spaces in the same column in
neighboring lines, stopping when hitting a wall.
This can be toggled with using |implicitbefore=|\meta{bool}
and |implicitafter=|\meta{bool}.
They are active by default.

\bigskip
\begin{dconsume}
nil before
unaligned
two before
one before
x   explicit
\end{dconsume}
\hfill
\drun{implicitbefore=false}%
\hfill
\drun{implicitbefore=true}%
\begin{dconsume}
x   explicit
one after
two after
unaligned
nil after
\end{dconsume}
\hfill
\drun{implicitafter=false}%
\hfill
\drun{implicitafter=true}%
\hfill
\bigskip

\autoverbalignsetup{final, chunk=\verb*}
\DescribeKey{indent}
By default we replace chunks consisting only of spaces with |\quad|.
You can set |indent=|\meta{code} instead, or set it to
empty |indent=,| to disable the replacement entirely.
\newcommand{\myindent}{{\color{red}$\rightarrow\,$}}

\bigskip
\begin{dconsume}
begin
       print
end
\end{dconsume}
\hfill
\drun{}%
\hfill
\drun{indent=\myindent}%
\hfill
\drun{indent=}%
\hfill
\drun{indent=, chunk=\lstinline}%
\hfill
\bigskip

In the example below, code is aligned
explicitly after the |begin|, but the |end| is indented by four spaces.
We insert indentations into the second column to ensure the |end| is never
on the same level as code appearing deeper, however this creates an ugly space
between |beg sub|.
Without implicit tabs the hierarchy is lost.

\bigskip
\begin{dconsume}
beg  sub
     beg  foo
          bar
       end
     beg  baz
          qux
       end
  end
\end{dconsume}
\hfill
\drunX{indent=, draft}%
\hfill
\drunX{indent=\myindent, chunk=\lstinline}%
\hfill
\drunX{implicitbefore=false, implicitafter=false, indent=, draft}%
\hfill
\drunX{implicitbefore=false, implicitafter=false, chunk=\lstinline, indent=\myindent}%
\hfill
\bigskip

\DescribeKey{global}
\DescribeKey{local}
This package uses \textsf{autotabbing} which aligns all tabs with the same ID.
The default, |global| alignment identifies the tabs by their column, aligning
all tabs originating in the same column across the entire block.
For longer blocks, this may not be desired.
Therefore |local| alignment only groups consecutive tabs in the same column
under the same ID.

\bigskip
\begin{dconsume}
f mmmmmm =       q
f     l  = mmmmm q
      l
g lll ll =       q
g        = ll l  q
somethinglong l
h nnnnnn =    l  q
h        = l l   q
somethinglong    q
g llllll =       q
g        =       q
\end{dconsume}
{\autotabbingsetup{draft}
\autoverbalignsetup{chunk=\lstinline}
\hfill
\drun{global}
\hfill
\drun{local}
}\hfill
\bigskip

\subsection{Hooks}

There are a number of hooks (initially empty) which can be used for customisation:
\DescribeKey{beforeblock}
\DescribeKey{afterblock}
These are executed just before and after the \textsf{autotabbing} environment,
in the same group.

\begin{dconsume}
do some  code
   return
\end{dconsume}
\bigskip\hfill\drun{%
chunk=\lstinline,
beforeblock=\lstset{language=Haskell},
afterblock=\textsf{end code}
}\hfill\bigskip

\DescribeKey{beforeline}
\DescribeKey{afterline}
These are executed at the start and end of each line, delimited by a tab each.
All lines are contained in the same group.

\newcounter{myLC}
\bigskip\hfill\drun{%
beforeline={\stepcounter{myLC}\Roman{myLC}},
afterline={\arabic{myLC}}
}\hfill\bigskip



\DescribeKey{beforechunk}
\DescribeKey{afterchunk}
These are executed before and after each chunk, not including indents.
They are contained in the same group as the content, one group per chunk.

\bigskip\hfill\drun{%
beforechunk={(},
afterchunk={)}
}\hfill\bigskip



\DocInput{autoverbalign.dtx}
\PrintChanges
\PrintIndex
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \StopEventually{}
% \section{Implementation}
%
% Load the Lua portion of the package
%    \begin{macrocode}
%<*package>
\RequirePackage{luatexbase}
\RequireLuaModule{autoverbalign}
%    \end{macrocode}
% Use \textsf{autotabbing} for actual alignment work.
%    \begin{macrocode}
\RequirePackage{autotabbing}
%    \end{macrocode}
% Define the options
%    \begin{macrocode}
\RequirePackage{kvoptions}
\SetupKeyvalOptions{family=autoverbalign, prefix=autoverbalign}
\DeclareStringOption[\verb]{chunk}
\DeclareStringOption[\quad]{indent}
\DeclareBoolOption[true]{implicitbefore}
\DeclareBoolOption[true]{implicitafter}
\DeclareBoolOption[true]{global}
\DeclareComplementaryOption{local}{global}
\DeclareBoolOption{draft}
\DeclareComplementaryOption{final}{draft}
\DeclareStringOption{beforeblock}
\DeclareStringOption{afterblock}
\DeclareStringOption{beforeline}
\DeclareStringOption{afterline}
\DeclareStringOption{beforechunk}
\DeclareStringOption{afterchunk}
\ProcessKeyvalOptions{autoverbalign}
%    \end{macrocode}
% \begin{macro}{\autoverbalignsetup}
% Set our options
%    \begin{macrocode}
\newcommand*{\autoverbalignsetup}{\setkeys{autoverbalign}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\autoverbalign@bool}
% Export a boolean option to Lua (there has to be a better way?!)
%    \begin{macrocode}
\newcommand{\autoverbalign@bool}[1]{%
  #1 = \csname ifautoverbalign#1\endcsname true\else false\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\autoverbalign@isdef}
% Export |true| to Lua if the option is not empty.
%    \begin{macrocode}
\newcommand{\autoverbalign@isdef}[1]{%
  #1 = \expandafter\ifx\csname autoverbalign#1\endcsname\empty%
    false\else true\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\autoverbalign@process}
% Process previously ingested lines.
%    \begin{macrocode}
\newcommand{\autoverbalign@process}{%
  \begingroup%
  \autoverbalignbeforeblock%
  \directlua{autoverbalign.process({
    \autoverbalign@bool{global},
    \autoverbalign@bool{implicitbefore},
    \autoverbalign@bool{implicitafter},
    \autoverbalign@isdef{indent},
    \autoverbalign@isdef{beforeline},
    \autoverbalign@isdef{afterline},
  })}%
  \autoverbalignafterblock%
  \endgroup%
}
%    \end{macrocode}
% \end{macro}
% \begin{environment}{autoverbalign@consume}
% A verbatim environment to pass raw lines to our Lua code.
%    \begin{macrocode}
\RequirePackage{verbatim}
\newenvironment{autoverbalign@consume}{%
  \begingroup%
  \directlua{autoverbalign.lines = {}}%
  \let\do\@makeother\dospecials\catcode`\^^M\active%
  \def\verbatim@processline{\directlua{autoverbalign.line()}}%
  \verbatim@start%
}{%
  \endgroup%
}
%    \end{macrocode}
% \end{environment}
% \begin{environment}{autoverbalign}
% Our main environment: set the options, consume input and process it.
%    \begin{macrocode}
\newenvironment{autoverbalign}[1][]{%
  \autoverbalignsetup{#1}
  \autoverbalign@consume%
}{%
  \endautoverbalign@consume%
  \autoverbalign@process%
}
%    \end{macrocode}
% \end{environment}
% \begin{macro}{\newautoverbalign}
% Create a new environment which first sets the options passed at creation
% on every use.
%    \begin{macrocode}
\newcommand*{\newautoverbalign}[2][]{
  \newenvironment{#2}{%
    \autoverbalignsetup{#1}%
    \autoverbalign%
  }{%
    \endautoverbalign%
  }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\autoverbaligntab}
% Create a named tabstop (first arg), of a certain type (second arg),
% this is only used to display a red or blue bar in |draft| mode.
%    \begin{macrocode}
\newcommand*{\autoverbaligntab}[2]{%
  \autotabbing@cell@next[#1]%
  \ifautoverbaligndraft%
    \raisebox{0pt}[0pt][0pt]{\makebox[0pt][r]{%
      \ifcase #2%explicit
        \color{red}%
      \or%implicit
        \color{blue}%
      \fi%
      \rule[-.3\baselineskip]{1pt}{\baselineskip}%
      \hspace{0.2em}%
    }}%
  \fi%
}
%</package>
%    \end{macrocode}
% \end{macro}
%
% The Lua portion of the package.
%    \begin{macrocode}
%<*lua>
local err, warn, info, log = luatexbase.provides_module({name = 'autoverbalign'})
autoverbalign = autoverbalign or {}
local opts
%    \end{macrocode}
% We use |string.strip| and |table.keys| from \textsf{lualibs}.
%    \begin{macrocode}
require('lualibs')
%    \end{macrocode}
% Receive a line from the register used by \textsf{verbatim}, store it in the table.
%    \begin{macrocode}
function autoverbalign.line()
  local line = tex.toks['verbatim@line']
  table.insert(autoverbalign.lines, {content = line})
end
%    \end{macrocode}
% There are two tab kinds at the moment: explicit, following two spaces,
% and implicit, neighboring another tab, following one space.
%    \begin{macrocode}
local pattern_explicit = '%s%s+'
local pattern_implicit = '%s.'
local kind_explicit, kind_implicit = 0, 1
%    \end{macrocode}
% Find explicit alignment by marking offsets where two spaces follow nonspaces.
% Tabs store their offset and a (for now) unique name. It is in a subtable to
% allow for multiple tabs to point at the same name for |local| alignment.
% |line.tabs| is a table to allow easy checking if a tab exists in a line.
%    \begin{macrocode}
local function find_explicit_tabs(lines)
  local tabid = 1
  for _, line in ipairs(lines) do
    line.tabs = {}
    local last = 1
    while last do
      _, last = line.content:find(pattern_explicit, last)
      if last then
        line.tabs[last] = {
          kind = kind_explicit,
          offset = last,
          name = {id = tabid, dep = {}},
        }
        tabid = tabid + 1
      end
    end
  end
end
%    \end{macrocode}
% Expand tabs to non-explicitly aligned neighbor lines. Iterates upwards
% and downwards from the current line, copying the source tag's name to
% matching targets, joining them. This is important for |local| alignment.
%    \begin{macrocode}
local function find_implicit_tabs(lines)
  if not (opts.implicitafter or opts.implicitbefore) then return end
  for i, line in ipairs(lines) do
    -- prepare (reversed) index lists
    local after = {}
    if opts.implicitafter then
      for j = i + 1, #lines do table.insert(after, j) end
    end
    local before = {}
    if opts.implicitbefore then
      for j = i - 1, 1, -1 do table.insert(before, j) end
    end
    for _, tab in pairs(line.tabs) do
      local function expand(idxs)
        for _, j in ipairs(idxs) do
          local p = lines[j]
          local reg = p.content:sub(tab.offset, tab.offset + 1)
          if reg:match(pattern_implicit) == reg then
            p.tabs[tab.offset] = {
              kind = kind_implicit,
              name = tab.name,
              offset = tab.offset,
            }
          else
            break
          end
        end
      end
      expand(after)
      expand(before)
    end
  end
end
%    \end{macrocode}
% Convert the |line.tabs| table into a list of tab objects sorted by offset.
%    \begin{macrocode}
local function tabs_list(lines)
  for _, line in ipairs(lines) do
    local offsets = table.keys(line.tabs)
    table.sort(offsets)
    local linear_tabs = {}
    for _, offset in ipairs(offsets) do
      table.insert(linear_tabs, line.tabs[offset])
    end
    line.tabs = linear_tabs
  end
end
%    \end{macrocode}
% For |global| alignemt, finding the final names is easy: it's the tab's offset.
%    \begin{macrocode}
local function rename_global(lines)
  for _, line in ipairs(lines) do
    for _, tab in ipairs(line.tabs) do
      tab.name.id = tab.offset
    end
  end
end
%    \end{macrocode}
% For |local| alignment, it's harder because we allow for quite complex layouts
% and \textsf{autotabbing} requires tab IDs to be sorted in each line to avoid
% impossible configurations.
% So we first build the DAG of tab dependencies: each tab is dependent on those
% to its left as these must have smaller IDs.
% Then we perform a depth-first search and assign new names in post-order,
% topologically sorting the tabs. We start with number 2 because 1 is used
% for the |beforeline| hook.
%    \begin{macrocode}
local function rename_local(lines)
  local rightmost = {name = {dep = {}}}
  -- tab dependency DAG.
  for _, line in ipairs(lines) do
    for i = 1, #line.tabs do
      local left = line.tabs[i].name
      local right = (line.tabs[i + 1] or rightmost).name
      right.dep[left.id] = left
    end
  end
  local nextname = 2
  -- depth-first search, assign names
  local function visit(parent)
    for _, child in pairs(parent.dep or {}) do
      if not child.visited then
        visit(child)
        child.visited = true
        child.id = nextname
        nextname = nextname + 1
      end
    end
  end
  visit(rightmost.name)
end
%    \end{macrocode}
% Write one chunk, either calling the |indent| code if set, or the |\verb|-like
% command which shows the chunk. We try a few different delimiters searching
% for one not contained in the chunk.
%    \begin{macrocode}
local function output_chunk(str)
  if opts.indent and str:strip():len() == 0 then
    return '{\\autoverbalignindent}'
  else
    local delims='!|@$&-+=_0123456789'
    local ch = nil
    for i = 1, #delims do
      local de = delims:sub(i,i)
      if not str:find(de, 1, true) then
        ch = de
        break
      end
    end
    if not ch then
      err(string.format('no delimiter found for chunk %q', str))
    end
    local s = '{\\autoverbalignbeforechunk'
    s = s .. string.format('\\autoverbalignchunk%s%s%s', ch, str, ch)
    s = s .. '\\autoverbalignafterchunk}'
    return s
  end
end
%    \end{macrocode}
% Output the entire content. Delimit lines by |\\|,
% If set call the |beforeline| code and tab, cut out the chunks and output
% them, using the named tabs. Finally a high tab and the |afterline| code.
%    \begin{macrocode}
local function output(lines)
  local s = '\\begin{autotabbing}'
  for i, line in ipairs(lines) do
    if i ~= 1 then
      s = s .. '\\\\'
    end
    if opts.beforeline then
      s = s .. '\\autoverbalignbeforeline&[1]'
    end
    -- first (and possible last if no tab on line)
    local last = {offset = nil}
    s = s .. output_chunk(line.content:sub(1, (line.tabs[1] or last).offset))

    for i, tab in ipairs(line.tabs) do
      s = s .. string.format('\\autoverbaligntab{%d}{%d}',
          tab.name.id, tab.kind)
      local left = tab.offset + 1
      local right = (line.tabs[i + 1] or last).offset
      local chunk = line.content:sub(left, right)
      s = s .. output_chunk(chunk)
    end
    if opts.afterline then
      s = s .. '&[999]\\autoverbalignafterline'
    end
  end
  s = s .. '\\end{autotabbing}'
  return s
end
%    \end{macrocode}
% Do all of the above:
%    \begin{macrocode}
function autoverbalign.process(_opts)
  opts = _opts
  local lines = autoverbalign.lines
  find_explicit_tabs(lines)
  find_implicit_tabs(lines)
  tabs_list(lines)
  if opts.global then
    rename_global(lines)
  else
    rename_local(lines)
  end
  tex.print(output(lines))
end
%</lua>
%    \end{macrocode}
%
%
% \Finale
\endinput
